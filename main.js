/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => HelixPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// helix-keybindings.ts
var HelixKeybindings = class {
  constructor(plugin) {
    this.pendingKeys = [];
    this.plugin = plugin;
  }
  enable() {
  }
  disable() {
    this.clearPendingKeys();
  }
  destroy() {
    this.disable();
  }
  handleNormalModeKey(event, editor) {
    const key = this.getKeyString(event);
    if (event.ctrlKey || event.metaKey || event.altKey) {
      return false;
    }
    this.pendingKeys.push(key);
    this.resetKeyTimeout();
    const command = this.pendingKeys.join("");
    if (this.executeCommand(command, editor)) {
      event.preventDefault();
      this.clearPendingKeys();
      return true;
    }
    if (this.isPartialCommand(command)) {
      event.preventDefault();
      return true;
    }
    this.clearPendingKeys();
    return false;
  }
  getKeyString(event) {
    if (event.key.length === 1) {
      return event.key;
    }
    switch (event.key) {
      case "Escape":
        return "<Esc>";
      case "Enter":
        return "<Enter>";
      case "Backspace":
        return "<BS>";
      case "Delete":
        return "<Del>";
      case "Tab":
        return "<Tab>";
      case "ArrowUp":
        return "<Up>";
      case "ArrowDown":
        return "<Down>";
      case "ArrowLeft":
        return "<Left>";
      case "ArrowRight":
        return "<Right>";
      default:
        return event.key;
    }
  }
  executeCommand(command, editor) {
    const mode = this.plugin.modes.getCurrentMode();
    
    // Check for custom motions first
    if (this.plugin.configManager && this.plugin.configManager.hasCustomMotion(command)) {
      return this.executeCustomMotion(command, editor);
    }
    
    switch (command) {
      // Movement (Helix uses hjkl like vim but with different philosophy)
      case "h":
        return this.moveLeft(editor);
      case "j":
        return this.moveDown(editor);
      case "k":
        return this.moveUp(editor);
      case "l":
        return this.moveRight(editor);
      // Word movement
      case "w":
        return this.moveWordForward(editor);
      case "b":
        return this.moveWordBackward(editor);
      case "e":
        return this.moveWordEnd(editor);
      // Line movement
      case "gh":
        return this.moveLineStart(editor);
      case "gl":
        return this.moveLineEnd(editor);
      case "gg":
        return this.moveFileStart(editor);
      case "ge":
        return this.moveFileEnd(editor);
      // Selection (Helix's selection-first approach)
      case "x":
        return this.selectLine(editor);
      case "X":
        return this.selectLineAbove(editor);
      case "v":
        return this.enterSelectMode(editor);
      case "V":
        return this.selectWholeLine(editor);
      // Selection with movement
      case "s":
        return this.selectWithMovement(editor);
      case ";":
        return this.extendSelection(editor);
      case ",":
        return this.shrinkSelection(editor);
      // Insert modes
      case "i":
        return this.insertBeforeCursor(editor);
      case "a":
        return this.insertAfterCursor(editor);
      case "I":
        return this.insertLineStart(editor);
      case "A":
        return this.insertLineEnd(editor);
      case "o":
        return this.insertNewLineBelow(editor);
      case "O":
        return this.insertNewLineAbove(editor);
      // Delete/Change
      case "d":
        return this.deleteSelection(editor);
      case "c":
        return this.changeSelection(editor);
      case "y":
        return this.yankSelection(editor);
      case "p":
        return this.pasteAfter(editor);
      case "P":
        return this.pasteBefore(editor);
      // Search
      case "/":
        return this.search(editor);
      case "n":
        return this.searchNext(editor);
      case "N":
        return this.searchPrevious(editor);
      // Undo/Redo
      case "u":
        return this.undo(editor);
      case "U":
        return this.redo(editor);
      default:
        return false;
    }
  }
  executeCustomMotion(command, editor) {
    const motion = this.plugin.configManager.getCustomMotion(command);
    if (!motion) return false;
    
    try {
      switch (motion.action) {
        case 'move':
          return this.executeCustomMove(motion.params, editor);
        case 'select':
          return this.executeCustomSelect(motion.params, editor);
        case 'insert':
          return this.executeCustomInsert(motion.params, editor);
        case 'delete':
          return this.executeCustomDelete(motion.params, editor);
        case 'change':
          return this.executeCustomChange(motion.params, editor);
        case 'yank':
          return this.executeCustomYank(motion.params, editor);
        case 'custom':
          return this.executeCustomCommand(motion.params, editor);
        default:
          console.warn(`Unknown custom motion action: ${motion.action}`);
          return false;
      }
    } catch (error) {
      console.error(`Error executing custom motion ${command}:`, error);
      return false;
    }
  }
  
  executeCustomMove(params, editor) {
    switch (params) {
      case 'word_forward_end':
        return this.moveWordEnd(editor);
      case 'word_backward_start':
        return this.moveWordBackward(editor);
      case 'paragraph_down':
        return this.moveParagraphDown(editor);
      case 'paragraph_up':
        return this.moveParagraphUp(editor);
      case 'line_start_smart':
        return this.moveLineStartSmart(editor);
      case 'line_end_smart':
        return this.moveLineEndSmart(editor);
      default:
        console.warn(`Unknown custom move: ${params}`);
        return false;
    }
  }
  
  executeCustomSelect(params, editor) {
    switch (params) {
      case 'word':
        return this.selectWordAtCursor(editor);
      case 'sentence':
        return this.selectSentence(editor);
      case 'paragraph':
        return this.selectParagraph(editor);
      case 'line_content':
        return this.selectLineContent(editor);
      case 'line_full':
        return this.selectLineFull(editor);
      default:
        console.warn(`Unknown custom select: ${params}`);
        return false;
    }
  }
  
  executeCustomInsert(params, editor) {
    // Custom insert actions can be added here
    return false;
  }
  
  executeCustomDelete(params, editor) {
    switch (params) {
      case 'word':
        this.selectWordAtCursor(editor);
        return this.deleteSelection(editor);
      default:
        return false;
    }
  }
  
  executeCustomChange(params, editor) {
    switch (params) {
      case 'word':
        this.selectWordAtCursor(editor);
        return this.changeSelection(editor);
      default:
        return false;
    }
  }
  
  executeCustomYank(params, editor) {
    switch (params) {
      case 'word':
        this.selectWordAtCursor(editor);
        return this.yankSelection(editor);
      default:
        return false;
    }
  }
  
  executeCustomCommand(params, editor) {
    // Custom commands can be added here
    // Examples: toggle_word_wrap, sort_selection, etc.
    switch (params) {
      case 'toggle_word_wrap':
        // Toggle word wrap functionality
        return true;
      case 'sort_selection':
        // Sort selected lines
        return this.sortSelection(editor);
      default:
        console.warn(`Unknown custom command: ${params}`);
        return false;
    }
  }

  isPartialCommand(command) {
    const partialCommands = ["g"];
    
    // Check if this might be a partial custom motion
    if (this.plugin.configManager) {
      const possibleMotions = Array.from(this.plugin.configManager.customMotions.keys())
        .filter(motion => motion.startsWith(command) && motion.length > command.length);
      if (possibleMotions.length > 0) return true;
    }
    
    return partialCommands.some((partial) => command.startsWith(partial) && command.length < 2);
  }
  clearPendingKeys() {
    this.pendingKeys = [];
    if (this.keyTimeout) {
      clearTimeout(this.keyTimeout);
    }
  }
  resetKeyTimeout() {
    if (this.keyTimeout) {
      clearTimeout(this.keyTimeout);
    }
    this.keyTimeout = setTimeout(() => {
      this.clearPendingKeys();
    }, 1e3);
  }
  // Movement commands
  moveLeft(editor) {
    const cursor = editor.getCursor();
    if (cursor.ch > 0) {
      editor.setCursor({ line: cursor.line, ch: cursor.ch - 1 });
    }
    return true;
  }
  moveRight(editor) {
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    if (cursor.ch < line.length) {
      editor.setCursor({ line: cursor.line, ch: cursor.ch + 1 });
    }
    return true;
  }
  moveUp(editor) {
    const cursor = editor.getCursor();
    if (cursor.line > 0) {
      editor.setCursor({ line: cursor.line - 1, ch: cursor.ch });
    }
    return true;
  }
  moveDown(editor) {
    const cursor = editor.getCursor();
    const lineCount = editor.lineCount();
    if (cursor.line < lineCount - 1) {
      editor.setCursor({ line: cursor.line + 1, ch: cursor.ch });
    }
    return true;
  }
  moveWordForward(editor) {
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    let pos = cursor.ch;
    while (pos < line.length && !/\w/.test(line[pos])) pos++;
    while (pos < line.length && /\w/.test(line[pos])) pos++;
    editor.setCursor({ line: cursor.line, ch: pos });
    return true;
  }
  moveWordBackward(editor) {
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    let pos = cursor.ch - 1;
    while (pos >= 0 && !/\w/.test(line[pos])) pos--;
    while (pos >= 0 && /\w/.test(line[pos])) pos--;
    editor.setCursor({ line: cursor.line, ch: Math.max(0, pos + 1) });
    return true;
  }
  moveWordEnd(editor) {
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    let pos = cursor.ch + 1;
    while (pos < line.length && !/\w/.test(line[pos])) pos++;
    while (pos < line.length && /\w/.test(line[pos])) pos++;
    editor.setCursor({ line: cursor.line, ch: Math.max(0, pos - 1) });
    return true;
  }
  moveLineStart(editor) {
    const cursor = editor.getCursor();
    editor.setCursor({ line: cursor.line, ch: 0 });
    return true;
  }
  moveLineEnd(editor) {
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    editor.setCursor({ line: cursor.line, ch: line.length });
    return true;
  }
  moveFileStart(editor) {
    editor.setCursor({ line: 0, ch: 0 });
    return true;
  }
  moveFileEnd(editor) {
    const lastLine = editor.lineCount() - 1;
    const line = editor.getLine(lastLine);
    editor.setCursor({ line: lastLine, ch: line.length });
    return true;
  }
  // Selection commands (Helix's selection-first philosophy)
  selectLine(editor) {
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    editor.setSelection(
      { line: cursor.line, ch: 0 },
      { line: cursor.line, ch: line.length }
    );
    this.plugin.modes.enterSelectMode();
    return true;
  }
  selectLineAbove(editor) {
    const cursor = editor.getCursor();
    if (cursor.line > 0) {
      const line = editor.getLine(cursor.line - 1);
      editor.setSelection(
        { line: cursor.line - 1, ch: 0 },
        { line: cursor.line - 1, ch: line.length }
      );
      this.plugin.modes.enterSelectMode();
    }
    return true;
  }
  enterSelectMode(editor) {
    this.plugin.modes.enterSelectMode();
    return true;
  }
  selectWholeLine(editor) {
    const cursor = editor.getCursor();
    editor.setSelection(
      { line: cursor.line, ch: 0 },
      { line: cursor.line + 1, ch: 0 }
    );
    this.plugin.modes.enterSelectMode();
    return true;
  }
  selectWithMovement(editor) {
    this.plugin.modes.enterSelectMode();
    return true;
  }
  extendSelection(editor) {
    return true;
  }
  shrinkSelection(editor) {
    return true;
  }
  // Insert mode commands
  insertBeforeCursor(editor) {
    this.plugin.modes.enterInsertMode();
    return true;
  }
  insertAfterCursor(editor) {
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    if (cursor.ch < line.length) {
      editor.setCursor({ line: cursor.line, ch: cursor.ch + 1 });
    }
    this.plugin.modes.enterInsertMode();
    return true;
  }
  insertLineStart(editor) {
    this.moveLineStart(editor);
    this.plugin.modes.enterInsertMode();
    return true;
  }
  insertLineEnd(editor) {
    this.moveLineEnd(editor);
    this.plugin.modes.enterInsertMode();
    return true;
  }
  insertNewLineBelow(editor) {
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    editor.setCursor({ line: cursor.line, ch: line.length });
    editor.replaceRange("\n", editor.getCursor());
    this.plugin.modes.enterInsertMode();
    return true;
  }
  insertNewLineAbove(editor) {
    const cursor = editor.getCursor();
    editor.setCursor({ line: cursor.line, ch: 0 });
    editor.replaceRange("\n", editor.getCursor());
    editor.setCursor({ line: cursor.line, ch: 0 });
    this.plugin.modes.enterInsertMode();
    return true;
  }
  // Edit commands
  deleteSelection(editor) {
    const selection = editor.getSelection();
    if (selection) {
      editor.replaceSelection("");
    }
    return true;
  }
  changeSelection(editor) {
    this.deleteSelection(editor);
    this.plugin.modes.enterInsertMode();
    return true;
  }
  yankSelection(editor) {
    const selection = editor.getSelection();
    if (selection) {
      navigator.clipboard.writeText(selection);
    }
    return true;
  }
  pasteAfter(editor) {
    navigator.clipboard.readText().then((text) => {
      const cursor = editor.getCursor();
      editor.setCursor({ line: cursor.line, ch: cursor.ch + 1 });
      editor.replaceRange(text, editor.getCursor());
    });
    return true;
  }
  pasteBefore(editor) {
    navigator.clipboard.readText().then((text) => {
      editor.replaceRange(text, editor.getCursor());
    });
    return true;
  }
  // Search commands
  search(editor) {
    this.plugin.app.commands.executeCommandById("editor:open-search");
    return true;
  }
  searchNext(editor) {
    this.plugin.app.commands.executeCommandById("editor:find-next");
    return true;
  }
  searchPrevious(editor) {
    this.plugin.app.commands.executeCommandById("editor:find-previous");
    return true;
  }
  // Undo/Redo
  undo(editor) {
    this.plugin.app.commands.executeCommandById("editor:undo");
    return true;
  }
  redo(editor) {
    this.plugin.app.commands.executeCommandById("editor:redo");
    return true;
  }
  
  // Custom motion implementations
  moveParagraphDown(editor) {
    const cursor = editor.getCursor();
    const content = editor.getValue();
    const lines = content.split('\n');
    let nextParagraph = cursor.line + 1;
    
    // Find next empty line (paragraph boundary)
    while (nextParagraph < lines.length && lines[nextParagraph].trim() !== '') {
      nextParagraph++;
    }
    // Skip empty lines
    while (nextParagraph < lines.length && lines[nextParagraph].trim() === '') {
      nextParagraph++;
    }
    
    if (nextParagraph < lines.length) {
      editor.setCursor({ line: nextParagraph, ch: 0 });
    }
    return true;
  }
  
  moveParagraphUp(editor) {
    const cursor = editor.getCursor();
    const content = editor.getValue();
    const lines = content.split('\n');
    let prevParagraph = cursor.line - 1;
    
    // Find previous empty line (paragraph boundary)
    while (prevParagraph >= 0 && lines[prevParagraph].trim() !== '') {
      prevParagraph--;
    }
    // Skip empty lines
    while (prevParagraph >= 0 && lines[prevParagraph].trim() === '') {
      prevParagraph--;
    }
    
    if (prevParagraph >= 0) {
      editor.setCursor({ line: prevParagraph, ch: 0 });
    }
    return true;
  }
  
  moveLineStartSmart(editor) {
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    const firstNonSpace = line.search(/\S/);
    
    if (firstNonSpace === -1 || cursor.ch === firstNonSpace) {
      // If line is empty or cursor at first non-space, go to column 0
      editor.setCursor({ line: cursor.line, ch: 0 });
    } else {
      // Otherwise go to first non-space character
      editor.setCursor({ line: cursor.line, ch: firstNonSpace });
    }
    return true;
  }
  
  moveLineEndSmart(editor) {
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    const lastNonSpace = line.search(/\s*$/);
    
    if (cursor.ch === lastNonSpace) {
      // If at last non-space, go to end of line
      editor.setCursor({ line: cursor.line, ch: line.length });
    } else {
      // Otherwise go to last non-space character
      editor.setCursor({ line: cursor.line, ch: lastNonSpace });
    }
    return true;
  }
  
  selectWordAtCursor(editor) {
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    let start = cursor.ch;
    let end = cursor.ch;
    
    // Find word boundaries
    while (start > 0 && /\w/.test(line[start - 1])) start--;
    while (end < line.length && /\w/.test(line[end])) end++;
    
    if (start < end) {
      editor.setSelection(
        { line: cursor.line, ch: start },
        { line: cursor.line, ch: end }
      );
      this.plugin.modes.enterSelectMode();
    }
    return true;
  }
  
  selectSentence(editor) {
    const cursor = editor.getCursor();
    const content = editor.getValue();
    const offset = editor.posToOffset(cursor);
    
    // Find sentence boundaries (. ! ?)
    let start = offset;
    let end = offset;
    
    // Find start of sentence
    while (start > 0 && !/[.!?]/.test(content[start - 1])) {
      start--;
    }
    // Skip whitespace at beginning
    while (start < content.length && /\s/.test(content[start])) {
      start++;
    }
    
    // Find end of sentence
    while (end < content.length && !/[.!?]/.test(content[end])) {
      end++;
    }
    if (end < content.length) end++; // Include the punctuation
    
    const startPos = editor.offsetToPos(start);
    const endPos = editor.offsetToPos(end);
    editor.setSelection(startPos, endPos);
    this.plugin.modes.enterSelectMode();
    return true;
  }
  
  selectParagraph(editor) {
    const cursor = editor.getCursor();
    const content = editor.getValue();
    const lines = content.split('\n');
    
    let startLine = cursor.line;
    let endLine = cursor.line;
    
    // Find paragraph start (previous empty line)
    while (startLine > 0 && lines[startLine - 1].trim() !== '') {
      startLine--;
    }
    
    // Find paragraph end (next empty line)
    while (endLine < lines.length - 1 && lines[endLine + 1].trim() !== '') {
      endLine++;
    }
    
    editor.setSelection(
      { line: startLine, ch: 0 },
      { line: endLine, ch: lines[endLine].length }
    );
    this.plugin.modes.enterSelectMode();
    return true;
  }
  
  selectLineContent(editor) {
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    const start = line.search(/\S/);
    const end = line.search(/\s*$/);
    
    if (start !== -1) {
      editor.setSelection(
        { line: cursor.line, ch: start },
        { line: cursor.line, ch: end }
      );
    } else {
      // Empty line, select nothing
      editor.setSelection(cursor, cursor);
    }
    this.plugin.modes.enterSelectMode();
    return true;
  }
  
  selectLineFull(editor) {
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    
    editor.setSelection(
      { line: cursor.line, ch: 0 },
      { line: cursor.line + 1, ch: 0 }
    );
    this.plugin.modes.enterSelectMode();
    return true;
  }
  
  sortSelection(editor) {
    const selection = editor.getSelection();
    if (selection) {
      const lines = selection.split('\n');
      const sorted = lines.sort().join('\n');
      editor.replaceSelection(sorted);
    }
    return true;
  }
};

// helix-modes.ts
var import_obsidian = require("obsidian");
var HelixModes = class {
  constructor(plugin) {
    this.currentMode = "NOR" /* NORMAL */;
    this.plugin = plugin;
    this.keyHandler = this.handleKeyEvent.bind(this);
    this.insertModeKeys = [];
    this.insertModeTimeout = null;
  }
  enable() {
    document.addEventListener("keydown", this.keyHandler, true);
    this.setMode("NOR" /* NORMAL */);
  }
  disable() {
    document.removeEventListener("keydown", this.keyHandler, true);
  }
  destroy() {
    this.disable();
  }
  getCurrentMode() {
    return this.currentMode;
  }
  setMode(mode) {
    this.currentMode = mode;
    this.plugin.updateModeIndicator(mode);
    this.updateEditorClass(mode);
  }
  updateEditorClass(mode) {
    var _a, _b;
    const activeView = this.plugin.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!activeView) return;
    const editorEl = (_b = (_a = activeView.editor) == null ? void 0 : _a.cm) == null ? void 0 : _b.dom;
    if (!editorEl) return;
    editorEl.classList.remove("helix-normal", "helix-insert", "helix-select");
    switch (mode) {
      case "NOR" /* NORMAL */:
        editorEl.classList.add("helix-normal");
        break;
      case "INS" /* INSERT */:
        editorEl.classList.add("helix-insert");
        break;
      case "SEL" /* SELECT */:
        editorEl.classList.add("helix-select");
        break;
    }
  }
  handleKeyEvent(event) {
    if (!this.plugin.settings.enabled) return false;
    const activeView = this.plugin.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!activeView) return false;
    if (this.currentMode === "INS" /* INSERT */) {
      if (event.key === "Escape") {
        event.preventDefault();
        this.setMode("NOR" /* NORMAL */);
        return true;
      }
      // Handle jk escape sequence
      if (this.handleInsertModeEscape(event, activeView.editor)) {
        return true;
      }
      return false;
    }
    if (this.currentMode === "NOR" /* NORMAL */ || this.currentMode === "SEL" /* SELECT */) {
      return this.plugin.keybindings.handleNormalModeKey(event, activeView.editor);
    }
    return false;
  }
  enterInsertMode() {
    this.setMode("INS" /* INSERT */);
  }
  enterSelectMode() {
    this.setMode("SEL" /* SELECT */);
  }
  enterNormalMode() {
    this.setMode("NOR" /* NORMAL */);
  }
  
  handleInsertModeEscape(event, editor) {
    // Get escape sequences from config or use default
    const escapeSequences = this.getInsertModeEscapeSequences();
    
    // Add current key to sequence
    this.insertModeKeys.push(event.key.toLowerCase());
    
    // Clear timeout if it exists
    if (this.insertModeTimeout) {
      clearTimeout(this.insertModeTimeout);
    }
    
    // Check if current sequence matches any escape sequence
    for (const sequence of escapeSequences) {
      if (this.insertModeKeys.length >= sequence.length) {
        const recentKeys = this.insertModeKeys.slice(-sequence.length);
        if (recentKeys.join('') === sequence) {
          // Remove the typed characters
          const cursor = editor.getCursor();
          const line = editor.getLine(cursor.line);
          const startPos = Math.max(0, cursor.ch - sequence.length);
          editor.replaceRange(
            '',
            { line: cursor.line, ch: startPos },
            { line: cursor.line, ch: cursor.ch }
          );
          
          // Switch to normal mode
          this.setMode("NOR" /* NORMAL */);
          this.insertModeKeys = [];
          event.preventDefault();
          return true;
        }
      }
    }
    
    // Set timeout to clear keys after delay
    this.insertModeTimeout = setTimeout(() => {
      this.insertModeKeys = [];
    }, 1000);
    
    return false;
  }
  
  getInsertModeEscapeSequences() {
    // Check if configManager has custom escape sequences
    if (this.plugin.configManager && this.plugin.configManager.customMotions.has('insert_escape')) {
      const customEscape = this.plugin.configManager.getCustomMotion('insert_escape');
      if (customEscape && customEscape.params) {
        return customEscape.params.split(',').map(seq => seq.trim());
      }
    }
    
    // Default escape sequences
    return ['jk', 'jj'];
  }
};

// selection-manager.ts
var SelectionManager = class {
  constructor(plugin) {
    this.selectionHistory = [];
    this.currentSelectionIndex = -1;
    this.plugin = plugin;
  }
  enable() {
  }
  disable() {
    this.selectionHistory = [];
    this.currentSelectionIndex = -1;
  }
  destroy() {
    this.disable();
  }
  saveSelection(editor) {
    const selection = editor.listSelections()[0];
    if (selection) {
      this.selectionHistory.push({
        from: selection.anchor,
        to: selection.head
      });
      this.currentSelectionIndex = this.selectionHistory.length - 1;
    }
  }
  restoreSelection(editor, index) {
    const targetIndex = index !== void 0 ? index : this.currentSelectionIndex;
    if (targetIndex >= 0 && targetIndex < this.selectionHistory.length) {
      const selection = this.selectionHistory[targetIndex];
      editor.setSelection(selection.from, selection.to);
    }
  }
  clearSelectionHistory() {
    this.selectionHistory = [];
    this.currentSelectionIndex = -1;
  }
  // Helix-style selection operations
  selectWordAtCursor(editor) {
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    let start = cursor.ch;
    let end = cursor.ch;
    while (start > 0 && /\w/.test(line[start - 1])) start--;
    while (end < line.length && /\w/.test(line[end])) end++;
    if (start < end) {
      editor.setSelection(
        { line: cursor.line, ch: start },
        { line: cursor.line, ch: end }
      );
      this.saveSelection(editor);
    }
  }
  extendSelectionToLineEnd(editor) {
    const selection = editor.listSelections()[0];
    if (selection) {
      const line = editor.getLine(selection.head.line);
      editor.setSelection(
        selection.anchor,
        { line: selection.head.line, ch: line.length }
      );
      this.saveSelection(editor);
    }
  }
  extendSelectionToLineStart(editor) {
    const selection = editor.listSelections()[0];
    if (selection) {
      editor.setSelection(
        selection.anchor,
        { line: selection.head.line, ch: 0 }
      );
      this.saveSelection(editor);
    }
  }
  selectAllMatchingSelections(editor) {
    const selection = editor.getSelection();
    if (selection) {
      const content = editor.getValue();
      const matches = [];
      let index = content.indexOf(selection);
      while (index !== -1) {
        const pos = editor.offsetToPos(index);
        const endPos = editor.offsetToPos(index + selection.length);
        matches.push({ anchor: pos, head: endPos });
        index = content.indexOf(selection, index + 1);
      }
      if (matches.length > 1) {
        if (matches[0]) {
          editor.setSelection(matches[0].anchor, matches[0].head);
        }
      }
    }
  }
  splitSelectionByLines(editor) {
    const selection = editor.listSelections()[0];
    if (selection) {
      const startLine = Math.min(selection.anchor.line, selection.head.line);
      const endLine = Math.max(selection.anchor.line, selection.head.line);
      editor.setSelection(
        { line: startLine, ch: 0 },
        { line: endLine, ch: editor.getLine(endLine).length }
      );
    }
  }
};

// helix-config.ts
var HelixConfigManager = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.customMotions = new Map();
    this.configPath = this.getConfigPath();
  }
  
  getConfigPath() {
    const vaultPath = this.plugin.app.vault.adapter.path.path;
    return `${vaultPath}/.helixrc`;
  }
  
  async loadConfig() {
    try {
      const fs = require('fs').promises;
      const configContent = await fs.readFile(this.configPath, 'utf8');
      this.parseConfig(configContent);
    } catch (error) {
      if (error.code !== 'ENOENT') {
        console.warn('Failed to load .helixrc:', error);
      }
    }
  }
  
  parseConfig(content) {
    const lines = content.split('\n');
    let currentSection = null;
    
    for (const line of lines) {
      const trimmed = line.trim();
      
      // Skip comments and empty lines
      if (!trimmed || trimmed.startsWith('#')) continue;
      
      // Section headers
      if (trimmed.startsWith('[') && trimmed.endsWith(']')) {
        currentSection = trimmed.slice(1, -1);
        continue;
      }
      
      // Parse motion definitions
      if (currentSection === 'motions') {
        this.parseMotionDefinition(trimmed);
      }
    }
  }
  
  parseMotionDefinition(line) {
    // Format: key = action_type:parameters
    // Examples:
    // gt = move:word_forward
    // gw = select:word
    // <leader>d = delete:line
    const match = line.match(/^(.+?)\s*=\s*(.+)$/);
    if (!match) return;
    
    const [, key, definition] = match;
    const [action, ...params] = definition.split(':');
    
    this.customMotions.set(key.trim(), {
      action: action.trim(),
      params: params.join(':').trim()
    });
  }
  
  getCustomMotion(key) {
    return this.customMotions.get(key);
  }
  
  hasCustomMotion(key) {
    return this.customMotions.has(key);
  }
  
  async createDefaultConfig() {
    const defaultConfig = `# Helix configuration file
# Syntax: key = action_type:parameters
# Available actions: move, select, insert, delete, change, custom

[motions]
# Custom word motions
gt = move:word_forward_end
gb = move:word_backward_start

# Custom selection motions  
gw = select:word
gs = select:sentence
gp = select:paragraph

# Custom line operations
gl = select:line_content
gL = select:line_full

# Custom navigation
gj = move:paragraph_down
gk = move:paragraph_up
gh = move:line_start_smart
ge = move:line_end_smart

# Custom edit operations
gd = delete:word
gc = change:word
gy = yank:word

# Examples of more complex motions:
# <leader>w = custom:toggle_word_wrap
# <leader>s = custom:sort_selection
`;
    
    try {
      const fs = require('fs').promises;
      await fs.writeFile(this.configPath, defaultConfig, 'utf8');
      return true;
    } catch (error) {
      console.error('Failed to create default .helixrc:', error);
      return false;
    }
  }
};

// settings.ts
var import_obsidian2 = require("obsidian");
var HelixSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Helix Editor Settings" });
    new import_obsidian2.Setting(containerEl).setName("Enable Helix Mode").setDesc("Enable or disable Helix editor keybindings").addToggle((toggle) => toggle.setValue(this.plugin.settings.enabled).onChange(async (value) => {
      this.plugin.settings.enabled = value;
      await this.plugin.saveSettings();
      this.plugin.updatePlugin();
    }));
    new import_obsidian2.Setting(containerEl).setName("Show Mode Indicator").setDesc("Display current mode in the status bar").addToggle((toggle) => toggle.setValue(this.plugin.settings.showModeIndicator).onChange(async (value) => {
      this.plugin.settings.showModeIndicator = value;
      await this.plugin.saveSettings();
      if (value) {
        this.plugin.createModeIndicator();
      } else {
        this.plugin.removeModeIndicator();
      }
    }));
    new import_obsidian2.Setting(containerEl).setName("Highlight Selections").setDesc("Highlight active selections with special styling").addToggle((toggle) => toggle.setValue(this.plugin.settings.highlightSelections).onChange(async (value) => {
      this.plugin.settings.highlightSelections = value;
      await this.plugin.saveSettings();
    }));
    
    containerEl.createEl("h3", { text: "Custom Configuration (.helixrc)" });
    
    new import_obsidian2.Setting(containerEl).setName("Create .helixrc file").setDesc("Create a default .helixrc configuration file in your vault root").addButton((button) => button.setButtonText("Create").setCta().onClick(async () => {
      const success = await this.plugin.configManager.createDefaultConfig();
      if (success) {
        new import_obsidian2.Notice("Created default .helixrc file");
      } else {
        new import_obsidian2.Notice("Failed to create .helixrc file");
      }
    }));
    
    new import_obsidian2.Setting(containerEl).setName("Reload .helixrc").setDesc("Reload custom motions from .helixrc file").addButton((button) => button.setButtonText("Reload").onClick(async () => {
      await this.plugin.configManager.loadConfig();
      new import_obsidian2.Notice("Reloaded .helixrc configuration");
    }));
    
    new import_obsidian2.Setting(containerEl).setName("Open .helixrc").setDesc("Open .helixrc file for editing").addButton((button) => button.setButtonText("Open").onClick(async () => {
      const configPath = this.plugin.configManager.configPath;
      try {
        const fs = require('fs');
        if (fs.existsSync(configPath)) {
          this.app.workspace.openLinkText('.helixrc', '', false);
        } else {
          new import_obsidian2.Notice(".helixrc file not found. Create it first.");
        }
      } catch (error) {
        new import_obsidian2.Notice("Failed to open .helixrc file");
      }
    }));
    
    // Show current custom motions
    const customMotionsEl = containerEl.createEl("div", { cls: "custom-motions-display" });
    if (this.plugin.configManager && this.plugin.configManager.customMotions.size > 0) {
      customMotionsEl.createEl("h4", { text: "Current Custom Motions" });
      const motionsTable = customMotionsEl.createEl("table", { cls: "custom-motions-table" });
      const headerRow = motionsTable.createEl("tr");
      headerRow.createEl("th", { text: "Key" });
      headerRow.createEl("th", { text: "Action" });
      
      for (const [key, motion] of this.plugin.configManager.customMotions) {
        const row = motionsTable.createEl("tr");
        row.createEl("td", { text: key, cls: "keybinding-key" });
        row.createEl("td", { text: `${motion.action}:${motion.params}`, cls: "keybinding-desc" });
      }
    } else {
      customMotionsEl.createEl("p", { text: "No custom motions defined. Create a .helixrc file to add custom keybindings." });
    }
    
    containerEl.createEl("h3", { text: "Keybinding Reference" });
    const referenceEl = containerEl.createEl("div", { cls: "helix-keybinding-reference" });
    const sections = [
      {
        title: "Movement",
        bindings: [
          ["h/j/k/l", "Move left/down/up/right"],
          ["w/b/e", "Move word forward/backward/end"],
          ["gh/gl", "Move to line start/end"],
          ["gg/ge", "Move to file start/end"]
        ]
      },
      {
        title: "Selection (Selection-First Philosophy)",
        bindings: [
          ["x", "Select entire line"],
          ["X", "Select line above"],
          ["v", "Enter select mode"],
          ["V", "Select whole line including newline"],
          ["s", "Select with movement"],
          [";", "Extend selection"],
          [",", "Shrink selection"]
        ]
      },
      {
        title: "Insert Mode",
        bindings: [
          ["i/a", "Insert before/after cursor"],
          ["I/A", "Insert at line start/end"],
          ["o/O", "Insert new line below/above"],
          ["Esc", "Exit insert mode"],
          ["jk/jj", "Exit insert mode (configurable)"]
        ]
      },
      {
        title: "Edit",
        bindings: [
          ["d", "Delete selection"],
          ["c", "Change selection (delete + insert)"],
          ["y", "Yank (copy) selection"],
          ["p/P", "Paste after/before cursor"]
        ]
      },
      {
        title: "Search & Navigation",
        bindings: [
          ["/", "Search"],
          ["n/N", "Next/previous search result"],
          ["u/U", "Undo/redo"]
        ]
      },
      {
        title: "Custom Motions (via .helixrc)",
        bindings: [
          ["gt/gb", "Word forward end/backward start"],
          ["gw/gs/gp", "Select word/sentence/paragraph"],
          ["gl/gL", "Select line content/full line"],
          ["gj/gk", "Move paragraph down/up"],
          ["gh/ge", "Smart line start/end"],
          ["gd/gc/gy", "Delete/change/yank word"]
        ]
      }
    ];
    sections.forEach((section) => {
      const sectionEl = referenceEl.createEl("div", { cls: "keybinding-section" });
      sectionEl.createEl("h4", { text: section.title });
      const tableEl = sectionEl.createEl("table");
      section.bindings.forEach(([key, desc]) => {
        const rowEl = tableEl.createEl("tr");
        rowEl.createEl("td", { text: key, cls: "keybinding-key" });
        rowEl.createEl("td", { text: desc, cls: "keybinding-desc" });
      });
    });
    // Add .helixrc documentation
    const helixrcInfoEl = containerEl.createEl("div", { cls: "helixrc-info" });
    helixrcInfoEl.innerHTML = `
			<strong>Custom .helixrc Configuration:</strong><br>
			Create a <code>.helixrc</code> file in your vault root to define custom motions and keybindings. 
			The file uses a simple syntax: <code>key = action:parameters</code><br><br>
			<strong>Available Actions:</strong>
			<ul style="margin: 5px 0; padding-left: 20px;">
				<li><code>move:</code> - Cursor movement (word_forward_end, paragraph_up, line_start_smart, etc.)</li>
				<li><code>select:</code> - Text selection (word, sentence, paragraph, line_content, etc.)</li>
				<li><code>delete:</code> - Delete operations (word, etc.)</li>
				<li><code>change:</code> - Change operations (word, etc.)</li>
				<li><code>yank:</code> - Copy operations (word, etc.)</li>
				<li><code>custom:</code> - Special functions (jk,jj for insert_escape, sort_selection, etc.)</li>
			</ul>
			<strong>Examples:</strong><br>
			<code>gw = select:word</code> - Select word under cursor<br>
			<code>insert_escape = custom:jk,jj</code> - Use jk/jj to exit insert mode<br>
			<code>gd = delete:word</code> - Delete word under cursor
		`;

    const philosophyEl = containerEl.createEl("div", { cls: "helix-philosophy" });
    philosophyEl.innerHTML = `
			<h3>Helix Philosophy & Features</h3>
			<p>Helix follows a "selection \u2192 action" model, different from Vim's "action \u2192 motion" approach:</p>
			<ul>
				<li><strong>Selection First:</strong> First select what you want to operate on, then perform the action</li>
				<li><strong>Visual Feedback:</strong> All operations show immediate visual feedback through selections</li>
				<li><strong>Composable:</strong> Commands can be combined naturally through the selection model</li>
				<li><strong>Predictable:</strong> What you see selected is exactly what will be affected</li>
				<li><strong>Customizable:</strong> Define your own motions and keybindings via <code>.helixrc</code> file</li>
				<li><strong>Vim-like Escape:</strong> Use <code>jk</code> or <code>jj</code> to exit insert mode (configurable)</li>
				<li><strong>Extended Motions:</strong> Custom paragraph, sentence, and smart line movements</li>
				<li><strong>Desktop Optimized:</strong> Full filesystem access for configuration management</li>
			</ul>
		`;
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  enabled: true,
  showModeIndicator: true,
  highlightSelections: true
};
var HelixPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    this.configManager = new HelixConfigManager(this);
    this.keybindings = new HelixKeybindings(this);
    this.modes = new HelixModes(this);
    this.selectionManager = new SelectionManager(this);
    this.addSettingTab(new HelixSettingTab(this.app, this));
    
    // Load .helixrc configuration
    await this.configManager.loadConfig();
    
    this.app.workspace.onLayoutReady(() => {
      this.initializePlugin();
    });
    this.addCommand({
      id: "toggle-helix-mode",
      name: "Toggle Helix Mode",
      callback: () => {
        this.settings.enabled = !this.settings.enabled;
        this.saveSettings();
        new import_obsidian3.Notice(`Helix mode ${this.settings.enabled ? "enabled" : "disabled"}`);
        this.updatePlugin();
      }
    });
    
    this.addCommand({
      id: "create-helixrc",
      name: "Create .helixrc file",
      callback: async () => {
        const success = await this.configManager.createDefaultConfig();
        if (success) {
          new import_obsidian3.Notice("Created default .helixrc file in vault root");
        } else {
          new import_obsidian3.Notice("Failed to create .helixrc file", 5000);
        }
      }
    });
    
    this.addCommand({
      id: "reload-helixrc",
      name: "Reload .helixrc file",
      callback: async () => {
        await this.configManager.loadConfig();
        new import_obsidian3.Notice("Reloaded .helixrc configuration");
      }
    });
    
    this.addCommand({
      id: "open-helixrc",
      name: "Open .helixrc file",
      callback: async () => {
        const configPath = this.configManager.configPath;
        try {
          const fs = require('fs');
          if (fs.existsSync(configPath)) {
            this.app.workspace.openLinkText('.helixrc', '', false);
          } else {
            new import_obsidian3.Notice(".helixrc file not found. Use 'Create .helixrc file' command first.");
          }
        } catch (error) {
          new import_obsidian3.Notice("Failed to open .helixrc file", 5000);
        }
      }
    });
  }
  onunload() {
    var _a, _b, _c;
    (_a = this.keybindings) == null ? void 0 : _a.destroy();
    (_b = this.modes) == null ? void 0 : _b.destroy();
    (_c = this.selectionManager) == null ? void 0 : _c.destroy();
    this.removeModeIndicator();
  }
  initializePlugin() {
    if (this.settings.enabled) {
      this.keybindings.enable();
      this.modes.enable();
      this.selectionManager.enable();
      this.createModeIndicator();
    }
  }
  updatePlugin() {
    if (this.settings.enabled) {
      this.initializePlugin();
    } else {
      this.keybindings.disable();
      this.modes.disable();
      this.selectionManager.disable();
      this.removeModeIndicator();
    }
  }
  createModeIndicator() {
    if (!this.settings.showModeIndicator) return;
    this.removeModeIndicator();
    this.modeIndicator = document.createElement("div");
    this.modeIndicator.className = "helix-mode-indicator";
    this.modeIndicator.textContent = "NOR";
    const statusBar = document.querySelector(".status-bar");
    if (statusBar) {
      statusBar.appendChild(this.modeIndicator);
    }
  }
  removeModeIndicator() {
    if (this.modeIndicator) {
      this.modeIndicator.remove();
      this.modeIndicator = null;
    }
  }
  updateModeIndicator(mode) {
    if (this.modeIndicator) {
      this.modeIndicator.textContent = mode;
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
