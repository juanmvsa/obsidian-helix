/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => HelixPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// helix-keybindings.ts
var HelixKeybindings = class {
  constructor(plugin) {
    this.pendingKeys = [];
    this.plugin = plugin;
  }
  enable() {
  }
  disable() {
    this.clearPendingKeys();
  }
  destroy() {
    this.disable();
  }
  handleNormalModeKey(event, editor) {
    const key = this.getKeyString(event);
    if (event.ctrlKey || event.metaKey || event.altKey) {
      return false;
    }
    this.pendingKeys.push(key);
    this.resetKeyTimeout();
    const command = this.pendingKeys.join("");
    if (this.executeCommand(command, editor)) {
      event.preventDefault();
      this.clearPendingKeys();
      return true;
    }
    if (this.isPartialCommand(command)) {
      event.preventDefault();
      return true;
    }
    this.clearPendingKeys();
    return false;
  }
  getKeyString(event) {
    if (event.key.length === 1) {
      return event.key;
    }
    switch (event.key) {
      case "Escape":
        return "<Esc>";
      case "Enter":
        return "<Enter>";
      case "Backspace":
        return "<BS>";
      case "Delete":
        return "<Del>";
      case "Tab":
        return "<Tab>";
      case "ArrowUp":
        return "<Up>";
      case "ArrowDown":
        return "<Down>";
      case "ArrowLeft":
        return "<Left>";
      case "ArrowRight":
        return "<Right>";
      default:
        return event.key;
    }
  }
  executeCommand(command, editor) {
    const mode = this.plugin.modes.getCurrentMode();
    switch (command) {
      // Movement (Helix uses hjkl like vim but with different philosophy)
      case "h":
        return this.moveLeft(editor);
      case "j":
        return this.moveDown(editor);
      case "k":
        return this.moveUp(editor);
      case "l":
        return this.moveRight(editor);
      // Word movement
      case "w":
        return this.moveWordForward(editor);
      case "b":
        return this.moveWordBackward(editor);
      case "e":
        return this.moveWordEnd(editor);
      // Line movement
      case "gh":
        return this.moveLineStart(editor);
      case "gl":
        return this.moveLineEnd(editor);
      case "gg":
        return this.moveFileStart(editor);
      case "ge":
        return this.moveFileEnd(editor);
      // Selection (Helix's selection-first approach)
      case "x":
        return this.selectLine(editor);
      case "X":
        return this.selectLineAbove(editor);
      case "v":
        return this.enterSelectMode(editor);
      case "V":
        return this.selectWholeLine(editor);
      // Selection with movement
      case "s":
        return this.selectWithMovement(editor);
      case ";":
        return this.extendSelection(editor);
      case ",":
        return this.shrinkSelection(editor);
      // Insert modes
      case "i":
        return this.insertBeforeCursor(editor);
      case "a":
        return this.insertAfterCursor(editor);
      case "I":
        return this.insertLineStart(editor);
      case "A":
        return this.insertLineEnd(editor);
      case "o":
        return this.insertNewLineBelow(editor);
      case "O":
        return this.insertNewLineAbove(editor);
      // Delete/Change
      case "d":
        return this.deleteSelection(editor);
      case "c":
        return this.changeSelection(editor);
      case "y":
        return this.yankSelection(editor);
      case "p":
        return this.pasteAfter(editor);
      case "P":
        return this.pasteBefore(editor);
      // Search
      case "/":
        return this.search(editor);
      case "n":
        return this.searchNext(editor);
      case "N":
        return this.searchPrevious(editor);
      // Undo/Redo
      case "u":
        return this.undo(editor);
      case "U":
        return this.redo(editor);
      default:
        return false;
    }
  }
  isPartialCommand(command) {
    const partialCommands = ["g"];
    return partialCommands.some((partial) => command.startsWith(partial) && command.length < 2);
  }
  clearPendingKeys() {
    this.pendingKeys = [];
    if (this.keyTimeout) {
      clearTimeout(this.keyTimeout);
    }
  }
  resetKeyTimeout() {
    if (this.keyTimeout) {
      clearTimeout(this.keyTimeout);
    }
    this.keyTimeout = setTimeout(() => {
      this.clearPendingKeys();
    }, 1e3);
  }
  // Movement commands
  moveLeft(editor) {
    const cursor = editor.getCursor();
    if (cursor.ch > 0) {
      editor.setCursor({ line: cursor.line, ch: cursor.ch - 1 });
    }
    return true;
  }
  moveRight(editor) {
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    if (cursor.ch < line.length) {
      editor.setCursor({ line: cursor.line, ch: cursor.ch + 1 });
    }
    return true;
  }
  moveUp(editor) {
    const cursor = editor.getCursor();
    if (cursor.line > 0) {
      editor.setCursor({ line: cursor.line - 1, ch: cursor.ch });
    }
    return true;
  }
  moveDown(editor) {
    const cursor = editor.getCursor();
    const lineCount = editor.lineCount();
    if (cursor.line < lineCount - 1) {
      editor.setCursor({ line: cursor.line + 1, ch: cursor.ch });
    }
    return true;
  }
  moveWordForward(editor) {
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    let pos = cursor.ch;
    while (pos < line.length && !/\w/.test(line[pos])) pos++;
    while (pos < line.length && /\w/.test(line[pos])) pos++;
    editor.setCursor({ line: cursor.line, ch: pos });
    return true;
  }
  moveWordBackward(editor) {
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    let pos = cursor.ch - 1;
    while (pos >= 0 && !/\w/.test(line[pos])) pos--;
    while (pos >= 0 && /\w/.test(line[pos])) pos--;
    editor.setCursor({ line: cursor.line, ch: Math.max(0, pos + 1) });
    return true;
  }
  moveWordEnd(editor) {
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    let pos = cursor.ch + 1;
    while (pos < line.length && !/\w/.test(line[pos])) pos++;
    while (pos < line.length && /\w/.test(line[pos])) pos++;
    editor.setCursor({ line: cursor.line, ch: Math.max(0, pos - 1) });
    return true;
  }
  moveLineStart(editor) {
    const cursor = editor.getCursor();
    editor.setCursor({ line: cursor.line, ch: 0 });
    return true;
  }
  moveLineEnd(editor) {
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    editor.setCursor({ line: cursor.line, ch: line.length });
    return true;
  }
  moveFileStart(editor) {
    editor.setCursor({ line: 0, ch: 0 });
    return true;
  }
  moveFileEnd(editor) {
    const lastLine = editor.lineCount() - 1;
    const line = editor.getLine(lastLine);
    editor.setCursor({ line: lastLine, ch: line.length });
    return true;
  }
  // Selection commands (Helix's selection-first philosophy)
  selectLine(editor) {
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    editor.setSelection(
      { line: cursor.line, ch: 0 },
      { line: cursor.line, ch: line.length }
    );
    this.plugin.modes.enterSelectMode();
    return true;
  }
  selectLineAbove(editor) {
    const cursor = editor.getCursor();
    if (cursor.line > 0) {
      const line = editor.getLine(cursor.line - 1);
      editor.setSelection(
        { line: cursor.line - 1, ch: 0 },
        { line: cursor.line - 1, ch: line.length }
      );
      this.plugin.modes.enterSelectMode();
    }
    return true;
  }
  enterSelectMode(editor) {
    this.plugin.modes.enterSelectMode();
    return true;
  }
  selectWholeLine(editor) {
    const cursor = editor.getCursor();
    editor.setSelection(
      { line: cursor.line, ch: 0 },
      { line: cursor.line + 1, ch: 0 }
    );
    this.plugin.modes.enterSelectMode();
    return true;
  }
  selectWithMovement(editor) {
    this.plugin.modes.enterSelectMode();
    return true;
  }
  extendSelection(editor) {
    return true;
  }
  shrinkSelection(editor) {
    return true;
  }
  // Insert mode commands
  insertBeforeCursor(editor) {
    this.plugin.modes.enterInsertMode();
    return true;
  }
  insertAfterCursor(editor) {
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    if (cursor.ch < line.length) {
      editor.setCursor({ line: cursor.line, ch: cursor.ch + 1 });
    }
    this.plugin.modes.enterInsertMode();
    return true;
  }
  insertLineStart(editor) {
    this.moveLineStart(editor);
    this.plugin.modes.enterInsertMode();
    return true;
  }
  insertLineEnd(editor) {
    this.moveLineEnd(editor);
    this.plugin.modes.enterInsertMode();
    return true;
  }
  insertNewLineBelow(editor) {
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    editor.setCursor({ line: cursor.line, ch: line.length });
    editor.replaceRange("\n", editor.getCursor());
    this.plugin.modes.enterInsertMode();
    return true;
  }
  insertNewLineAbove(editor) {
    const cursor = editor.getCursor();
    editor.setCursor({ line: cursor.line, ch: 0 });
    editor.replaceRange("\n", editor.getCursor());
    editor.setCursor({ line: cursor.line, ch: 0 });
    this.plugin.modes.enterInsertMode();
    return true;
  }
  // Edit commands
  deleteSelection(editor) {
    const selection = editor.getSelection();
    if (selection) {
      editor.replaceSelection("");
    }
    return true;
  }
  changeSelection(editor) {
    this.deleteSelection(editor);
    this.plugin.modes.enterInsertMode();
    return true;
  }
  yankSelection(editor) {
    const selection = editor.getSelection();
    if (selection) {
      navigator.clipboard.writeText(selection);
    }
    return true;
  }
  pasteAfter(editor) {
    navigator.clipboard.readText().then((text) => {
      const cursor = editor.getCursor();
      editor.setCursor({ line: cursor.line, ch: cursor.ch + 1 });
      editor.replaceRange(text, editor.getCursor());
    });
    return true;
  }
  pasteBefore(editor) {
    navigator.clipboard.readText().then((text) => {
      editor.replaceRange(text, editor.getCursor());
    });
    return true;
  }
  // Search commands
  search(editor) {
    this.plugin.app.commands.executeCommandById("editor:open-search");
    return true;
  }
  searchNext(editor) {
    this.plugin.app.commands.executeCommandById("editor:find-next");
    return true;
  }
  searchPrevious(editor) {
    this.plugin.app.commands.executeCommandById("editor:find-previous");
    return true;
  }
  // Undo/Redo
  undo(editor) {
    this.plugin.app.commands.executeCommandById("editor:undo");
    return true;
  }
  redo(editor) {
    this.plugin.app.commands.executeCommandById("editor:redo");
    return true;
  }
};

// helix-modes.ts
var import_obsidian = require("obsidian");
var HelixModes = class {
  constructor(plugin) {
    this.currentMode = "NOR" /* NORMAL */;
    this.plugin = plugin;
    this.keyHandler = this.handleKeyEvent.bind(this);
  }
  enable() {
    document.addEventListener("keydown", this.keyHandler, true);
    this.setMode("NOR" /* NORMAL */);
  }
  disable() {
    document.removeEventListener("keydown", this.keyHandler, true);
  }
  destroy() {
    this.disable();
  }
  getCurrentMode() {
    return this.currentMode;
  }
  setMode(mode) {
    this.currentMode = mode;
    this.plugin.updateModeIndicator(mode);
    this.updateEditorClass(mode);
  }
  updateEditorClass(mode) {
    var _a, _b;
    const activeView = this.plugin.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!activeView) return;
    const editorEl = (_b = (_a = activeView.editor) == null ? void 0 : _a.cm) == null ? void 0 : _b.dom;
    if (!editorEl) return;
    editorEl.classList.remove("helix-normal", "helix-insert", "helix-select");
    switch (mode) {
      case "NOR" /* NORMAL */:
        editorEl.classList.add("helix-normal");
        break;
      case "INS" /* INSERT */:
        editorEl.classList.add("helix-insert");
        break;
      case "SEL" /* SELECT */:
        editorEl.classList.add("helix-select");
        break;
    }
  }
  handleKeyEvent(event) {
    if (!this.plugin.settings.enabled) return false;
    const activeView = this.plugin.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!activeView) return false;
    if (this.currentMode === "INS" /* INSERT */) {
      if (event.key === "Escape") {
        event.preventDefault();
        this.setMode("NOR" /* NORMAL */);
        return true;
      }
      return false;
    }
    if (this.currentMode === "NOR" /* NORMAL */ || this.currentMode === "SEL" /* SELECT */) {
      return this.plugin.keybindings.handleNormalModeKey(event, activeView.editor);
    }
    return false;
  }
  enterInsertMode() {
    this.setMode("INS" /* INSERT */);
  }
  enterSelectMode() {
    this.setMode("SEL" /* SELECT */);
  }
  enterNormalMode() {
    this.setMode("NOR" /* NORMAL */);
  }
};

// selection-manager.ts
var SelectionManager = class {
  constructor(plugin) {
    this.selectionHistory = [];
    this.currentSelectionIndex = -1;
    this.plugin = plugin;
  }
  enable() {
  }
  disable() {
    this.selectionHistory = [];
    this.currentSelectionIndex = -1;
  }
  destroy() {
    this.disable();
  }
  saveSelection(editor) {
    const selection = editor.listSelections()[0];
    if (selection) {
      this.selectionHistory.push({
        from: selection.anchor,
        to: selection.head
      });
      this.currentSelectionIndex = this.selectionHistory.length - 1;
    }
  }
  restoreSelection(editor, index) {
    const targetIndex = index !== void 0 ? index : this.currentSelectionIndex;
    if (targetIndex >= 0 && targetIndex < this.selectionHistory.length) {
      const selection = this.selectionHistory[targetIndex];
      editor.setSelection(selection.from, selection.to);
    }
  }
  clearSelectionHistory() {
    this.selectionHistory = [];
    this.currentSelectionIndex = -1;
  }
  // Helix-style selection operations
  selectWordAtCursor(editor) {
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    let start = cursor.ch;
    let end = cursor.ch;
    while (start > 0 && /\w/.test(line[start - 1])) start--;
    while (end < line.length && /\w/.test(line[end])) end++;
    if (start < end) {
      editor.setSelection(
        { line: cursor.line, ch: start },
        { line: cursor.line, ch: end }
      );
      this.saveSelection(editor);
    }
  }
  extendSelectionToLineEnd(editor) {
    const selection = editor.listSelections()[0];
    if (selection) {
      const line = editor.getLine(selection.head.line);
      editor.setSelection(
        selection.anchor,
        { line: selection.head.line, ch: line.length }
      );
      this.saveSelection(editor);
    }
  }
  extendSelectionToLineStart(editor) {
    const selection = editor.listSelections()[0];
    if (selection) {
      editor.setSelection(
        selection.anchor,
        { line: selection.head.line, ch: 0 }
      );
      this.saveSelection(editor);
    }
  }
  selectAllMatchingSelections(editor) {
    const selection = editor.getSelection();
    if (selection) {
      const content = editor.getValue();
      const matches = [];
      let index = content.indexOf(selection);
      while (index !== -1) {
        const pos = editor.offsetToPos(index);
        const endPos = editor.offsetToPos(index + selection.length);
        matches.push({ anchor: pos, head: endPos });
        index = content.indexOf(selection, index + 1);
      }
      if (matches.length > 1) {
        if (matches[0]) {
          editor.setSelection(matches[0].anchor, matches[0].head);
        }
      }
    }
  }
  splitSelectionByLines(editor) {
    const selection = editor.listSelections()[0];
    if (selection) {
      const startLine = Math.min(selection.anchor.line, selection.head.line);
      const endLine = Math.max(selection.anchor.line, selection.head.line);
      editor.setSelection(
        { line: startLine, ch: 0 },
        { line: endLine, ch: editor.getLine(endLine).length }
      );
    }
  }
};

// settings.ts
var import_obsidian2 = require("obsidian");
var HelixSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Helix Editor Settings" });
    new import_obsidian2.Setting(containerEl).setName("Enable Helix Mode").setDesc("Enable or disable Helix editor keybindings").addToggle((toggle) => toggle.setValue(this.plugin.settings.enabled).onChange(async (value) => {
      this.plugin.settings.enabled = value;
      await this.plugin.saveSettings();
      this.plugin.updatePlugin();
    }));
    new import_obsidian2.Setting(containerEl).setName("Show Mode Indicator").setDesc("Display current mode in the status bar").addToggle((toggle) => toggle.setValue(this.plugin.settings.showModeIndicator).onChange(async (value) => {
      this.plugin.settings.showModeIndicator = value;
      await this.plugin.saveSettings();
      if (value) {
        this.plugin.createModeIndicator();
      } else {
        this.plugin.removeModeIndicator();
      }
    }));
    new import_obsidian2.Setting(containerEl).setName("Highlight Selections").setDesc("Highlight active selections with special styling").addToggle((toggle) => toggle.setValue(this.plugin.settings.highlightSelections).onChange(async (value) => {
      this.plugin.settings.highlightSelections = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Keybinding Reference" });
    const referenceEl = containerEl.createEl("div", { cls: "helix-keybinding-reference" });
    const sections = [
      {
        title: "Movement",
        bindings: [
          ["h/j/k/l", "Move left/down/up/right"],
          ["w/b/e", "Move word forward/backward/end"],
          ["gh/gl", "Move to line start/end"],
          ["gg/ge", "Move to file start/end"]
        ]
      },
      {
        title: "Selection (Selection-First Philosophy)",
        bindings: [
          ["x", "Select entire line"],
          ["X", "Select line above"],
          ["v", "Enter select mode"],
          ["V", "Select whole line including newline"]
        ]
      },
      {
        title: "Insert Mode",
        bindings: [
          ["i/a", "Insert before/after cursor"],
          ["I/A", "Insert at line start/end"],
          ["o/O", "Insert new line below/above"],
          ["Esc", "Exit insert mode"]
        ]
      },
      {
        title: "Edit",
        bindings: [
          ["d", "Delete selection"],
          ["c", "Change selection (delete + insert)"],
          ["y", "Yank (copy) selection"],
          ["p/P", "Paste after/before cursor"]
        ]
      },
      {
        title: "Search & Navigation",
        bindings: [
          ["/", "Search"],
          ["n/N", "Next/previous search result"],
          ["u/U", "Undo/redo"]
        ]
      }
    ];
    sections.forEach((section) => {
      const sectionEl = referenceEl.createEl("div", { cls: "keybinding-section" });
      sectionEl.createEl("h4", { text: section.title });
      const tableEl = sectionEl.createEl("table");
      section.bindings.forEach(([key, desc]) => {
        const rowEl = tableEl.createEl("tr");
        rowEl.createEl("td", { text: key, cls: "keybinding-key" });
        rowEl.createEl("td", { text: desc, cls: "keybinding-desc" });
      });
    });
    const philosophyEl = containerEl.createEl("div", { cls: "helix-philosophy" });
    philosophyEl.innerHTML = `
			<h3>Helix Philosophy</h3>
			<p>Helix follows a "selection \u2192 action" model, different from Vim's "action \u2192 motion" approach:</p>
			<ul>
				<li><strong>Selection First:</strong> First select what you want to operate on, then perform the action</li>
				<li><strong>Visual Feedback:</strong> All operations show immediate visual feedback through selections</li>
				<li><strong>Composable:</strong> Commands can be combined naturally through the selection model</li>
				<li><strong>Predictable:</strong> What you see selected is exactly what will be affected</li>
			</ul>
		`;
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  enabled: true,
  showModeIndicator: true,
  highlightSelections: true
};
var HelixPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    this.keybindings = new HelixKeybindings(this);
    this.modes = new HelixModes(this);
    this.selectionManager = new SelectionManager(this);
    this.addSettingTab(new HelixSettingTab(this.app, this));
    this.app.workspace.onLayoutReady(() => {
      this.initializePlugin();
    });
    this.addCommand({
      id: "toggle-helix-mode",
      name: "Toggle Helix Mode",
      callback: () => {
        this.settings.enabled = !this.settings.enabled;
        this.saveSettings();
        new import_obsidian3.Notice(`Helix mode ${this.settings.enabled ? "enabled" : "disabled"}`);
        this.updatePlugin();
      }
    });
  }
  onunload() {
    var _a, _b, _c;
    (_a = this.keybindings) == null ? void 0 : _a.destroy();
    (_b = this.modes) == null ? void 0 : _b.destroy();
    (_c = this.selectionManager) == null ? void 0 : _c.destroy();
    this.removeModeIndicator();
  }
  initializePlugin() {
    if (this.settings.enabled) {
      this.keybindings.enable();
      this.modes.enable();
      this.selectionManager.enable();
      this.createModeIndicator();
    }
  }
  updatePlugin() {
    if (this.settings.enabled) {
      this.initializePlugin();
    } else {
      this.keybindings.disable();
      this.modes.disable();
      this.selectionManager.disable();
      this.removeModeIndicator();
    }
  }
  createModeIndicator() {
    if (!this.settings.showModeIndicator) return;
    this.removeModeIndicator();
    this.modeIndicator = document.createElement("div");
    this.modeIndicator.className = "helix-mode-indicator";
    this.modeIndicator.textContent = "NOR";
    const statusBar = document.querySelector(".status-bar");
    if (statusBar) {
      statusBar.appendChild(this.modeIndicator);
    }
  }
  removeModeIndicator() {
    if (this.modeIndicator) {
      this.modeIndicator.remove();
      this.modeIndicator = null;
    }
  }
  updateModeIndicator(mode) {
    if (this.modeIndicator) {
      this.modeIndicator.textContent = mode;
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
